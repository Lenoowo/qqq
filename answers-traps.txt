然后，我们可以阅读函数g、f和main的代码，并回答以下问题：
1.哪些寄存器储存了函数的参数？例如，哪些寄存器存储了在主函数被调用的printf的参数13?
RISC-V提供了8个寄存器用于传参，为a0 - a7，超过8个参数之后的参数通过栈传递。在main调用printf时，13应该保存在寄存器a2中。

2.主函数中对f和g的调用在哪里？
在上面的代码中，没有看到对f和g函数调用的代码，这是因为g函数被内联到f函数中，f函数被内联到main函数中。可以看到main中直接把f(8) + 1的值传递给了a1寄存器，没有对f函数进行调用，而是有编译器直接计算出调用结果12。
3.printf函数位于哪个地址？
主函数中对printf间接寻址，其地址位于 ra + 1536 处。而auipc指令将0x0左移12位，然后加到pc上，并将结果写入ra。这一行代码的开头即为pc当前的值，因此pc = 0x30。那么有pc = 0x30 = ra。得printf地址位于 30 + 1536 = 0x630 处。

4.在 main 中 jalr 到 printf 之后的寄存器 ra 中有什么值？
上面的jalr指令，不仅设置了pc的值用于函数跳转，还会将下一条指令的地址保存到寄存器ra（即printf调用返回main之后的地址）。由于指令是32位，所以应该将ra设置为当前pc + 4，所以ra = pc + 4 = 0x34 + 0x04 = 0x38
5.运行以下代码：
unsigned int i = 0x00646c72;printf("H%x Wo%s", 57616, &i);
输出是什么？上述输出是基于RISC-V为小端法的事实的。如果RISC-V为大端法，i应该被设置为什么，57616需要被改变吗？
运⾏结果：打印出了 He110 World 。

⾸先， 57616 转换为 16 进制为 e110 ，所以格式化描述符 %x 打印出了它的 16 进制值。在⼩端（little-endian）处理器中，数据 0x00646c72 的⾼字节存储在内存的⾼位，那么从内存低位，也就是低字节开始读取，对应的 ASCII 字符为 rld。如果在⼤端（big-endian）处理器中，数据 0x00646c72 的⾼字节存储在内存的低位，那么从内存低位，也就是⾼字节开始读取其 ASCII 码为 dlr 。
如果为大端法，i需要被更改为0x726c640，才能保证从内存低位读取时的输出为 rld 。⽆论 57616 在⼤端序还是⼩端序，它的⼆进制值都为 e110 。⼤端序和⼩端序只是改变了多字节数据在内存中的存放⽅式，并不改变其真正的值的⼤⼩，所以 57616 始终打印为⼆进制e110。
6.在下面的代码中，会打印 'y='什么？为什么会发生这种情况？
printf("x=%dy=%d", 3);
会打印出 a2 寄存器当前的值，因为在调用 printf 时，并未给 a2 寄存器赋值，但在printf被执行的时候却无法检查当前 a2 中的值是否为用户传入的值，而只是单纯的对其进行打印。